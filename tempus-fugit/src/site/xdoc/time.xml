<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2009-2010, tempus-fugit committers
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<document xmlns="http://maven.apache.org/XDOC/2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>Time-dependence</title>
        <author>Toby Weston</author>
    </properties>

    <body>

        <section name="Time-dependence">
         <p>The <code>com.google.code.tempusfugit.temporal</code> package contains classes and interfaces
                designed to help when writing time-dependant code. We've found it particularly useful when writing
             test code and by implication, making code more testable.
            </p>
            <ul>
                <li><p><a href="#Duration">Duration</a></p></li>
                <li><p><a href="#Conditions_and_Waiting">Conditions and Waiting</a></p></li>
                <ul>
                    <li><p><a href="#Condition">Condition</a></p></li>
                    <li><p><a href="#WaitFor">WaitFor</a></p></li>
                    <li><p><a href="#Timeouts">Timeouts</a></p></li>
                </ul>
                <li><p><a href="#Time">Time</a></p></li>
                <ul>
                    <li><p><a href="#Stop_Watches">Stop Watches</a></p></li>
                    <li><p><a href="#Controlling_Time_with_Clock">Controlling Time with Clock</a></p></li>
                    <li><p><a href="#Deterministic_Clock">Deterministic Clock</a></p></li>
                    <li><p><a href="#The_Factory_Interface">The Factory Interface</a></p></li>
                </ul>
            </ul>
        </section>

        <section name="Duration">
        <p>
            Frequently, some length of time is represented as a <code>long</code> in Java. The trouble here is that you
            don't always know what time unit the <code>long</code> represents and as <a href="http://java.sun.com/docs/books/effective/">Effective Java</a> recommends, you'll often end up with
            something like the following
        </p>
        <source>connection.setReadTimeout(TIMEOUT_IN_MILLIS);</source>
        or you might come across unhelpful code like this;
        <source>connection.setReadTimeout(1000 * 2 * 60);</source>
        <p>
            This is all very error prone, ugly and in the second case, fails to convey the intent. The <code><a href="xref/com/google/code/tempusfugit/temporal/Duration.html">Duration</a></code>
            class captures a length of time and forces you to express the time unit. So, for example,
        </p>
        <source>connection.setReadTimeout(seconds(2);</source>
        </section>
        <p>
            Using <code>Duration</code> in your own method forces your clients to create use an explicit time unit and you
            can convert back explicitly. for example,
        </p>
        <source>
public void setReadTimeout(Duration timeout) {
   ...
   readTimeout = timeout.inMillis();         
   ...
}</source>

        <section name="Conditions and Waiting">
            <subsection name="Condition">
            <p>
                Conditions are part of our everyday language. The <code><a href="xref/com/google/code/tempusfugit/temporal/Condition.html">Condition</a></code>
                interface captures a conditional as something that can be reused. For example, waiting for something can be
                achieved using the <code><a href="xref/com/google/code/tempusfugit/temporal/WaitFor.html">WaitFor</a></code> class and an anonymous <code>Condition</code>. For example,
            </p>
        <source>
private void waitForShutdown() throws TimeoutException {
    waitOrTimeout(new Condition() {
        public boolean isSatisfied() {
            return server.isShutdown();
        }
    }, timeout);
 } </source>
            <p>
                will wait for some <code>server</code> to indicate that it has shutdown. The <code>Conditions</code> class
                collects useful <code>Condition</code> objects such as <code>not</code>. There is also a useful <code>Condition</code>
                to indicate if a thread is in a waiting state in <code>ThreadUtils</code>.
            </p>
            <p>
                Some common thread related conditions have been collected in the <code><a href="xref/com/google/code/tempusfugit/temporal/Conditions.html">Conditions</a></code>
                class. These include a <i>not</i> condition to invert the result of some other condition and various
                thread state related conditions such as checking if a a thread alive. See the <a href="concurrency.html#Miscellaneous">miscellaneous thread utils</a>
                section for details.
            </p>
            <p>
                For testing purposes, you might want to assert against the outcome of a <code>Condition</code>. The
                <code>Conditions</code> class has an <code>assertThat</code> method which takes a <code>Matcher&lt;Boolean&gt;</code>
                for use with junit. For example, you could assert against a condition using vanilla junit like this.
            </p>
                <source>Assert.assertThat(not(TRUE).isSatisfied(), is(false)); </source>
            <p>
                or using the <code>Conditions</code> class, you can tidy the assert up to look like this. 
            </p>
                <source>Conditions.assertThat(not(TRUE), is(false)); </source>
            </subsection>

            <subsection name="WaitFor">
                <p>
                    The <code><a href="xref/com/google/code/tempusfugit/temporal/WaitFor.html">WaitFor</a></code> class can be used to periodically 
                    check if a <code><a href="xref/com/google/code/tempusfugit/temporal/Condition.html">Condition</a></code> is satisfied,
                    sleeping for a short period if it has not before checking again. The methods available are </p>
                <ul>
                    <li><p><code>waitOrTimeout</code></p></li>
                    <li><p><code>waitUntil</code></p></li>
                </ul>
                <p>                                 
                    The <code>waitOrTimeout</code> will wait until the condition is satisfied or timeout after a specified
                    <code>Timeout</code>. The <code>waitUntil</code> waits until a given timeout without checking against any
                    condition. Both methods can be interrupted and so throw an <code>InterruptedException</code>. The sleep
                    period between condition checks is defaulted but since version 1.1 can be overridden (by passing in
                    a implementation of <code><a href="xref/com/google/code/tempusfugit/temporal/Sleeper.html">Sleeper</a></code>
                    such as <code><a href="xref/com/google/code/tempusfugit/temporal/ThreadSleeper.html">ThreadSleeper</a></code>).
                </p>
                <p>
                   For example, waiting for a thread to move into a waiting state can be implemented like this;
               </p>
<source>
private void waitForStartup(final Thread thread) throws TimeoutException, InterruptedException {
    waitOrTimeout(new Condition() {
        public boolean isSatisfied() {
            return (thread.getState() == TIMED_WAITING) || (thread.getState() == WAITING);
        }
    }, timeout(seconds(10)));
} </source>
              <p>
                  Where <code>WaitFor.waitOrTime</code> has been statically imported and <code>Timeout.timeout</code> is a
                  static constructor for a <code>Timeout</code> object.
              </p>
              <p>
                  See the <a href="concurrency.html#Miscellaneous">concurrency</a> section for a set of pre-defined <code>Condition</code>s.
              </p>
            </subsection>

            <subsection name="Timeouts">
            <p>
                The <code><a href="xref/com/google/code/tempusfugit/temporal/Timeout.html">Timeout</a></code> class takes 
                a <code>Duration</code> representing a period after which a timeout has occurred. The timeout status of
                the object is checked using the <code>hasExpired</code> method. <b>Note</b> that the timeout uses a
                <code>StopWatch</code> internally and that the stop watch is started on construction.
            </p>
            <p>
                <code>Timeout</code> class is combined with a <code>Condition</code> to implement the <code>waitUntil</code>
                method of <code>WaitFor</code>.
            </p>
            </subsection>

        </section>
        <section name="Time">
            <subsection name="Stop Watches">
            <p>
                The <code><a href="xref/com/google/code/tempusfugit/temporal/StopWatch.html">StopWatch</a></code> class allows you to record the length of time taken between starting and stopping
                the watch. It's used internally with the <code>WaitFor.waitUntil(Timeout timeout, ...)</code> class. <b>Note</b>
                that the stop watch will start on construction.
            </p>           
            </subsection>

            <subsection name="Controlling Time with Clock">
            <p>
                The <code><a href="xref/com/google/code/tempusfugit/temporal/Clock">Clock</a></code> interface along with its default implementation
                <code><a href="xref/com/google/code/tempusfugit/temporal/DefaultClock">DefaultClock</a></code>
                are aimed at making testing classes that require a date easier. Rather than pass around <code>java.util.Date</code>
                classes which will return the current date when constructed, you can pass around a factory which allows
                you to control the date.
            </p>
            <p>
                For example, the <code>StopWatch</code> class maintains an internal <code>Date</code> which it can use
                to compare with the current time to work out the elapsed time. A straight forward implementation might look like this
            </p>
                <source>
public class BadStopWatch {

    private Date startDate;
    private long elapsedTime;

    public BadStopWatch() {
        this.startDate = new Date();
    }

    public Duration getElapsedTime() {
        return millis(new Date().getTime() - startDate.getTime());
    }
}</source>
                <p>
                    Writing the (rather silly) test below highlights a problem using real time in the class.
                </p>
                <source>
public class BadStopWatchTest {
    @Test
    public void getElapsedTime() {
        BadStopWatch watch = new BadStopWatch();
        ThreadUtils.sleep(millis(100));
        assertThat(watch.getElapsedTime(), is(millis(100)));
    }
 } </source>
                <p>
                    The test is unlikely to pass!
                </p>
                <source>
    java.lang.AssertionError:
Expected: is &lt;Duration 100 MILLISECONDS&gt;
     got: &lt;Duration 103 MILLISECONDS&gt;
	at org.junit.Assert.assertThat(Assert.java:778)
	at org.junit.Assert.assertThat(Assert.java:736)
	at com.google.code.tempusfugit.temporal.BadStopWatchTest.getElapsedTime(BadStopWatchTest.java:32) </source>

                <p>
                    Whereas, if we write the class using a controllable time, we can write a more deterministic test. Here,
                    we create an alternative stop watch implementation and mock the factory using <a href="http://www.jmock.org/">jmock</a>.
                </p>
                <source>
public class BetterStopWatch {

    private Date startDate;
    private long elapsedTime;
    private Clock clock;

    public BetterStopWatch(Clock clock) {
        this.clock = clock;
        this.startDate = clock.now();
    }

    public Duration getElapsedTime() {
        return millis(clock.now().getTime() - startDate.getTime());
    }
}</source>
          <p>The test becomes clearer</p>
          <source>
@Test
public void getElapsedTimeFromBetterStopWatch() {
    context.checking(new Expectations() {{
        one(clock).now(); will(returnValue(new Date(0)));
        one(clock).now(); will(returnValue(new Date(100)));
    }});
    BetterStopWatch watch = new BetterStopWatch(time);
    assertThat(watch.getElapsedTime(), is(millis(100)));
}</source>

            </subsection>

            <subsection name="Movable Clock">
                <p>
                    You can use the <code><a href="xref/com/google/code/tempusfugit/temporal/MovableClock.html">MovableClock</a></code> in tests to explicitly move time forward within
                    the context of a test. For example, we can rewrite the test above as follows.
                </p>
                <source>
@Test
public void getElapsedTimeUsingMovableClock() {
    MovableClock clock = new MovableClock();
    BetterStopWatch watch = new BetterStopWatch(clock);
    assertThat(watch.getElapsedTime(), is(millis(0)));
    clock.incrementBy(millis(100));
    assertThat(watch.getElapsedTime(), is(millis(100)));
} </source>
            </subsection>

            <subsection name="The Factory Interface">
            <p>
                The generic <code><a href="xref/com/google/code/tempusfugit/Factory.html">Factoy&lt;T&gt;</a></code> interface is
                a general purpose factory classes or simply declare your factories in generic terms (ie
                <code>Factory&lt;Date&gt; factory = ...</code>) and pass these around.
            </p>
            </subsection>
        </section>
    </body>

</document>