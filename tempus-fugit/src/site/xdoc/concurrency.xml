<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2009, tempus-fugit committers
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<document xmlns="http://maven.apache.org/XDOC/2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>Concurrency</title>
        <author>Toby Weston</author>
    </properties>

    <body>

        <section name="Concurrency">
            <p>The <code>com.google.code.tempusfugit.concurrency</code> package contains classes and interfaces
                designed to help when developing concurrent code.    
            </p>
            <ul>
                <li><p><a href="#Thread_Utilities">Thread Utilities</a></p></li>
                <ul>
                    <li><p><a href="#Sleeping_and_Interruptions">Sleeping and Interruptions</a></p></li>
                    <li><p><a href="#Scheduled_Interruption">Scheduled Interruption</a></p></li>
                    <li><p><a href="#Thread_Dumps">Thread Dumps</a></p></li>
                    <li><p><a href="Deadlock_Detection">Deadlock Detection</a></p></li>
                    <li><p><a href="#Miscellaneous">Miscellaneous</a></p></li>
                </ul>
                <li><p><a href="Intermittent_Tests">Intermittent Tests</a></p></li>
                <li><p><a href="#Callables">Callables</a></p></li>
                <ul>
                    <li><p>Convert to a <code>Runnable</code> using <a href="Callable_Adapter">Callable Adapter</a></p></li>
                    <li><p>Throw specific exceptions with <a href="#tempus-fugit_Callable">tempus-fugit Callable</a></p></li>
                </ul>
            </ul>

        </section>

        <section name="Thread Utilities">

        <subsection name="Sleeping and Interruptions">
        <p>Often, you'll see code like the example below</p>
            <source>
try {
   Thread.sleep(100);
} catch (InterruptedException e) {
   // nothing
}</source>
            <p>tempus-fugit captures the annoying boiler plate code needed to reset the interrupt flat in situations where you
                can't or don't want to rethrow the <code>InterruptedException</code>.
                </p>
            <p>Using the <code><a href="xref/com/google/code/tempusfugit/concurrency/ThreadUtils.html">ThreadUtils</a>.sleep</code> method, the above code is rewritten as.</p>
<source>sleep(millis(100));</source>
            <p>This ensures that the interrupt flag is reset and is more explicit about the <a href="time.html#Duration">duration</a> of the sleep.</p>
            <p>If you want to ensure the interrupt flag is reset for other code, you can use the <code>ThreadUtils.resetInterruptFlagWhen</code>
            method directly. The <code><a href="xref/com/google/code/tempusfugit/concurrency/Interruptible.html">Interruptible</a></code> interface is used to highlight that the closure-like call
                you want to execute does in fact throw the <code>InterruptedException</code>. For example;
            </p>
            <source>
resetInterruptFlagWhen(new Interruptible&lt;Void&gt;() {
    public Void call() throws InterruptedException {
        Thread.sleep(100);
        return null;
    }
}); </source>
            <p>Extracting the closure-like <code>Interruptible</code> to a method makes the code more expressive;</p>
            <source>resetInterruptFlagWhen(sleepingIsInterrupted()); </source>
            <p>This is actually how the <code>ThreadUtils.sleep</code> method is implemented within tempus-fugit.</p>
        </subsection>

        <subsection name="Scheduled Interruption">
        <p>
            The <code><a href="xref/com/google/code/tempusfugit/concurrency/Interrupter.html">Interrupter</a></code> class allows you to schedule an <code>interrupt</code> on a thread after a
            specified duration. This can be useful when implementing timeouts on classes that support the use of <code>interrupt</code> as an interruption policy. For example, the code below
            sets up an interrupt to be scheduled after some timeout, before embarking on some potentially long running process. The <code>Interrupter</code> and <code>Thread</code> classes
            have been statically imported.
        </p>
<source>
Interrupter interrupter = interrupt(currentThread()).after(timeout);
try {
    while (!currentThread().isInterrupted()) {
        // some long running process
    }
} finally {
    interrupter.cancel();
} </source>
        <p>
            The <code>Interrupter</code> spawns a thread which sleeps (using <code><a href="xref/com/google/code/tempusfugit/temporal/WaitFor.html">WaitFor</a></code>) until the timeout expires.
            It then just calls <code>interrupt</code> on the passed in thread. It is important therefore to ensure you cancel the interrupt as above for the case when the long running process
            could finish before the timeout. The <code>cancel</code> has no affect if the timeout has already expired so using a <code>finally</code> block is recommended.
        </p>
        <p>The <code><a href="xref/com/google/code/tempusfugit/concurrency/DefaultTimeoutableCompletionService.html">DefaultTimeoutableCompletionService</a></code> classes uses this
            approach to implement a <code>java.util.concurrent.CompletionService</code>-like service that will timeout and return any completed tasks and abandoning any remaining.</p>
            
        </subsection>

        <subsection name="Interrupt Capturing Thread Stub">
        <p>
            It can be tricky to test that an interrupt has been called on a thread because of the possibility of race conditions between calling <code>interrupt</code> and checking
            the status of the interrupt flag using <code>Thread.isInterrupted()</code> or <code>Thread.interrupted</code>. For example, the interrupt status can be reset when a thread
            goes into the <code>TERMINATED</code> state. You can use the <code>WaitFor</code> class to express an assertion must be true within a given time (as below) but in this case,
            the race conditions can still occur (due to the frequency of the check whilst waiting). In the example below, the created thread will perform some blocking function that can
            be interrupted (for example, sleeping) and we're testing that the call to <code>interrupt</code> will wake and change the interrupt status flag (asserting against <code>thread.isInterrupted</code>).
        </p>
            <source>
@Test (timeout = 500)
public void interrupted() throws TimeoutException, InterruptedException {
    final Thread thread = new Thread(new Runnable(...));
    thread.start();
    waitOrTimeout(threadIsWaiting(thread), millis(500));
    thread.interrupt();
    <b>waitOrTimeout(new Condition() {
        public boolean isSatisfied() {
            return thread.isInterrupted();
        }
    }</b>, millis(500));
} </source>
            <p>
                It may be simpler to use a <i>stub</i> to capture the interrupt. The <code><a href="xref/com/google/code/tempusfugit/concurrency/InterruptCapturingThread.html">InterruptCapturingThread</a></code> class of tempus-fugit is just a stub extending <code>Thread</code>
                which records and gives access to stack traces of threads that call <code>interrupt</code> on it.
            </p>
            <source>
@Test (timeout = 500)
public void interrupted() throws TimeoutException, InterruptedException {
    InterruptCapturingThread thread = new InterruptCapturingThread(new Runnable(...));
    thread.start();
    waitOrTimeout(threadIsWaiting(thread), millis(500));
    thread.interrupt();
    waitOrTimeout(not(threadIsWaiting(thread)), millis(500));
    <b>assertThat(thread.getInterrupters().isEmpty(), is(false));</b>
} </source>
            <p>
                For testing purposes, you can also get a view on the stack traces of the threads that called <code>interrupt</code> on your thread. Calling <code>thread.printStackTraceOfInterruptingThreads(System.out)</code>
                from the example above would show something like the following.
            </p>
            <source>
java.lang.Thread.getStackTrace(Thread.java:1409)
   com.google.code.tempusfugit.concurrency.InterruptCapturingThread.interrupt(InterruptCapturingThread.java:61)
   com.google.code.tempusfugit.concurrency.InterruptCapturingThreadTest.interrupted(InterruptCapturingThreadTest.java:39)
   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
   java.lang.reflect.Method.invoke(Method.java:585)
   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
   org.junit.internal.runners.statements.FailOnTimeout$1.run(FailOnTimeout.java:28) </source>
        </subsection>

        <subsection name="Thread Dumps">
            <p>
                The <a href="xref/com/google/code/tempusfugit/concurrency/ThreadDump.html">ThreadDump</a> class offers a programmatic way to print a thread dump. It's not recommended for production
                code but can be handy in tracking down unexpected behaviour interactively. Using <code>ThreadDump.dumpThreads(System.out)</code>,
                for example, would yield something like the following (formatting inspired by <code>jstack</code>).
            </p>
 <source>
 Thread Reference Handler@2: (state = WAITING)
 - java.lang.Object.wait(Native Method)
 - java.lang.Object.wait(Object.java:474)
 - java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)

Thread main@1: (state = RUNNABLE)
 - java.lang.Thread.dumpThreads(Native Method)
 - java.lang.Thread.getAllStackTraces(Thread.java:1460)
 - com.google.code.tempusfugit.concurrency.ThreadDump.dumpThreads(ThreadDump.java:25)
  ...
 - com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:118)
 - com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40)

Thread Signal Dispatcher@4: (state = RUNNABLE)

Thread Finalizer@3: (state = WAITING)
 - java.lang.Object.wait(Native Method)
 - java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:120)
 - java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:136)
 - java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)
 </source>
            <p>
                 The <code>dumpThreads</code> method will also detect any Java-level deadlocks, see the
                <a href="#Deadlock_Detection">Deadlock Detection</a> section for details.
            </p>
        </subsection>

         <subsection name="Deadlock Detection">
             <p>
                 The <code><a href="xref/com/google/code/tempusfugit/concurrency/DeadlockDetector.html">DeadlockDetector</a></code> class allows you to programmatically detect basic deadlocks in your 
                 Java code. You can output deadlocks using the following code (note that printing a thread dump using the <code>ThreadDump</code> class will automatically attempt to find
                 any deadlocks).
             </p>
             <source>DeadlockDetector.printDeadlocks(System.out);</source>
             <p>
                 There are various types of deadlock in concurrent systems, broadly speaking with regard to Java,
                 they can be categorised as
             </p>
             <ul>
                 <li><p>Java monitor cyclic locking dependency</p></li>
                 <li><p>Java <code>Lock</code> cyclic locking dependency</p></li>
                 <li><p>Internal resource starvation <i>or</i> live lock</p></li>
                 <li><p>External resource based</p></li>
             </ul>
             <p>
                 The <code>DeadlockDecector</code> class can only spot Java monitor cyclic locking problems. It's implementation
                 is basically the same as <code>jconsole</code> and <code>jstack</code> and suffers the same limitations.
                 Java 1.6 versions of <code>jstack</code> and <code>jconsole</code> can additionally detect <code>Lock</code>
                 based cyclic problems. The types of deadlock it can detect can be illustrated in the example below.
             </p>
             <source>
 public void potentialDeadlock() {
     new Kidnapper().start();
     new Negotiator().start();
 }

 public class Kidnapper extends Thread {
     public void run() {
         synchronized (nibbles) {
             synchronized (cash) {
                 take(cash);
             }
         }
     }
 }

 public class Negotiator extends Thread {
     public void run() {
         synchronized (cash) {
             synchronized (nibbles) {
                 take(nibbles);
             }
         }
     }
 } </source>
             <p>
                 Here, the <code>Kidnapper</code> is unwilling to release poor Nibbles the <code>Cat</code> until he
                 has the <code>Cash</code> but our <code>Negotiator</code> is unwilling to part with the <code>Cash</code>
                 until he has poor Nibbles back in his arms. The deadlock detector displays this woeful situation as follows.
             </p>
             <source>
Deadlock detected
=================

"Negotiator-Thread-1":
 waiting to lock Monitor of com.google.code.tempusfugit.concurrency.DeadlockDetectorTest$Cat@ce4a8a
 which is held by "Kidnapper-Thread-0"

"Kidnapper-Thread-0":
 waiting to lock Monitor of com.google.code.tempusfugit.concurrency.DeadlockDetectorTest$Cash@7fc8b2
 which is held by "Negotiator-Thread-1"
             </source>
         </subsection>

         <subsection name="Miscellaneous">
            <p>Some additional thread utilities include the following</p>
            <ul>
                <li><p><code>ThreadUtils.threadIsWaiting</code></p>
            <p>The static method <code>ThreadUtils.threadIsWaiting(Thread)</code> offers a <code><a href="xref/com/google/code/tempusfugit/temporal/Condition.html">Condition</a></code>
             that allows you to test if a thread is waiting. Combining the condition with some classes from the <a href="time.html#Conditions_and_Waiting">temporal</a> package allows you to wait for a
             thread to <b>not</b> be in the waiting state, for example. Using tempus-fugit, you would express is something like the following.
         </p>
             <source>waitOrTimeout(not(threadIsWaiting(thread)), seconds(10)); </source>
            </li>
                <li>
             <p>As a convenience class, the <code><a href="xref/com/google/code/tempusfugit/concurrency/DefaultThreadFactory.html">DefaultThreadFactory</a></code> offers an implementation of <code>java.util.concurrent.ThreadFactory</code>
             that creates a thread using the single argument constructor of <code>Thread</code>.</p>
                 </li>          
            </ul>

         </subsection>
        </section>

        <!--<section name="Intermittent Tests">-->
        <!--</section>-->

        <section name="Callables">
            <subsection name="Callable Adapter">
                <p>
                    The <code>java.util.concurrent.Executors</code> class has helper methods to convert from a
                    <code>Runnable</code> to a <code>Callable</code> but lacks a counterpart to convert a <code>Callable</code>
                    to a <code>Runnable</code>. This is presumably because a <code>Runnable</code> lacks the ability to
                    throw exceptions or return values.
                </p>
                <p>
                    Both <code>Runnable</code> and <code>Callable</code> are handy interfaces to express closure-like functionality
                    in Java. Discounting their close relationship to concurrency mechanisms in Java, they both really
                    just represent something that can be called. Choosing between the two, the <code>Callable</code> is
                    more powerful.
                </p>
                <p>
                    The <code><a href="xref/com/google/code/tempusfugit/concurrency/CallableAdapter.html">CallableAdapter</a></code> class will convert from a <code>Callable</code> into a <code>Runnable</code>
                    wrapping any exception as a <code>RuntimeException</code> and discarding any return type. This allows
                    you to write general task code in the form of a <code>Callable</code> without necessarily being hampered
                    if you need to pass in a <code>Runnable</code> to some framework code.
                </p>
                <p>
                    As a concrete example, Java's <code>ScheduledExecutorService</code> class doesn't allow you to schedule
                    a task with a fixed delay or at a fixed rate. The interface takes a <code>Runnable</code>. However,
                    using the adapter you can schedule a <code>Callable</code> at a fixed rate (ignoring the result). The
                    underlying <code>Callable</code> task could then be used elsewhere where the result is actually used.
                </p>
            </subsection>

            <subsection name="tempus-fugit Callable">
            <p>The <code><a href="xref/com/google/code/tempusfugit/concurrency/Callable.html">Callable</a></code> interface extends <code>java.util.concurrent.Callable</code> but allows you to specify the
                exception as a generic type. This class has a fairly limited usage and isn't recommended over the standard
                Java version. Instead, if you create a method that takes a <code>java.util.concurrent.Callable</code> as a
                argument, calling it will force the method to throw <code>Exception</code>. If instead, you pass in a
                <code>com.google.code.tempusfugit.concurrency.Callable</code>, you can specify the specific exception to
                throw and therefore avoid being forced to throw <code>Exception</code>. For example</p>
                <source>
public &lt;T&gt; T foo(java.util.concurrent.Callable&lt;T&gt; callable) throws <b>Exception</b> {
    return callable.call();
} </source>
                <p>Whereas using the tempus-fugit version allows a more specific exception to be thrown.</p>
                <source>
public &lt;T&gt; T bar(com.google.code.tempusfugit.concurrency.Callable&lt;T, <b>RuntimeException</b>&gt; callable) {
    return callable.call();
} </source>
            </subsection>
        </section>
    </body>

</document>