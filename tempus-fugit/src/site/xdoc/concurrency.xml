<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2009-2010, tempus-fugit committers
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software 
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<document xmlns="http://maven.apache.org/XDOC/2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>Concurrency</title>
        <author>Toby Weston</author>
    </properties>

    <body>

        <section name="Concurrency">
            <p>The <code>com.google.code.tempusfugit.concurrency</code> package contains classes and interfaces
                designed to help when developing concurrent code.    
            </p>
            <ul>
                <li><p><a href="#Thread_Utilities">Thread Utilities</a></p></li> 
                <ul>
                    <li><p><a href="#Sleeping_and_Interruptions">Sleeping and Interruptions</a></p></li>
                    <li><p><a href="#Scheduled_Interruption">Scheduled Interruption</a></p></li>
                    <li><p><a href="#Thread_Dumps">Thread Dumps</a></p></li>
                    <li><p><a href="Deadlock_Detection">Deadlock Detection</a></p></li>
                    <li><p><a href="#Miscellaneous">Miscellaneous</a></p></li>
                </ul>
                <li><p><a href="#Concurrency_Utilities">Concurrency Utilities</a></p></li>
                <ul>
                    <li><p><a href="#Countdown_Latch_with_Timeout">Countdown Latch with Timeout</a></p></li>
                    <li><p><a href="#Timeoutable_Completion_Service">Timeoutable Completion Service</a></p></li>
                </ul>
                <li><p><a href="#JUnit_Integration">JUnit Integration</a></p></li>
                <ul>
                    <li><p><a href="Intermittent_Tests">Intermittent Tests</a></p></li>
                    <li><p><a href="Parallel_Tests">Parallel Tests</a></p></li>
                    <li><p><a href="Load__Soak_Tests">Load / Soak Tests</a></p></li>
                    <li><p><a href="Wait_for_Assertions">Wait for Assertions</a></p></li>
                    <li><p><a href="Interrupt_Capturing_Thread_Stub">Interrupt Capturing Thread Stub</a></p></li>
                </ul>
                <li><p><a href="#Callables">Callables</a></p></li>
                <ul>
                    <li><p>Convert to a <code>Runnable</code> using <a href="Callable_Adapter">Callable Adapter</a></p></li>
                    <li><p>Throw specific exceptions with <a href="#tempus-fugit_Callable">tempus-fugit Callable</a></p></li>
                </ul>
            </ul>

        </section>

        <section name="Thread Utilities">

        <subsection name="Sleeping and Interruptions">
        <p>Often, you'll see code like the example below</p>
            <source>
try {
   Thread.sleep(100);
} catch (InterruptedException e) {
   // nothing
}</source>
            <p>tempus-fugit captures the annoying boiler plate code needed to reset the interrupt flat in situations where you
                can't or don't want to rethrow the <code>InterruptedException</code>.
                </p>
            <p>Using the <code><a href="xref/com/google/code/tempusfugit/concurrency/ThreadUtils.html">ThreadUtils</a>.sleep</code> method, the above code is rewritten as.</p>
<source>sleep(millis(100));</source>
            <p>This ensures that the interrupt flag is reset and is more explicit about the <a href="time.html#Duration">duration</a> of the sleep.</p>
            <p>If you want to ensure the interrupt flag is reset for other code, you can use the <code>ThreadUtils.resetInterruptFlagWhen</code>
            method directly. The <code><a href="xref/com/google/code/tempusfugit/concurrency/Interruptible.html">Interruptible</a></code> interface is used to highlight that the closure-like call
                you want to execute does in fact throw the <code>InterruptedException</code>. For example;
            </p>
            <source>
resetInterruptFlagWhen(new Interruptible&lt;Void&gt;() {
    public Void call() throws InterruptedException {
        Thread.sleep(100);
        return null;
    }
}); </source>
            <p>Extracting the closure-like <code>Interruptible</code> to a method makes the code more expressive;</p>
            <source>resetInterruptFlagWhen(sleepingIsInterrupted()); </source>
            <p>This is actually how the <code>ThreadUtils.sleep</code> method is implemented within tempus-fugit.</p>
        </subsection>

        <subsection name="Scheduled Interruption">
        <p>
            The <code><a href="xref/com/google/code/tempusfugit/concurrency/Interrupter.html">Interrupter</a></code> class allows you to schedule an <code>interrupt</code> on a thread after a
            specified duration. This can be useful when implementing timeouts on classes that support the use of <code>interrupt</code> as an interruption policy. For example, the code below
            sets up an interrupt to be scheduled after some timeout, before embarking on some potentially long running process. The <code>Interrupter</code> and <code>Thread</code> classes
            have been statically imported.
        </p>
<source>
Interrupter interrupter = interrupt(currentThread()).after(timeout);
try {
    while (!currentThread().isInterrupted()) {
        // some long running process
    }
} finally {
    interrupter.cancel();
} </source>
        <p>
            The <code>Interrupter</code> spawns a thread which sleeps (using <code><a href="xref/com/google/code/tempusfugit/temporal/WaitFor.html">WaitFor</a></code>) until the timeout expires.
            It then just calls <code>interrupt</code> on the passed in thread. It is important therefore to ensure you cancel the interrupt as above for the case when the long running process
            could finish before the timeout. The <code>cancel</code> has no affect if the timeout has already expired so using a <code>finally</code> block is recommended.
        </p>
        <p>The <code><a href="xref/com/google/code/tempusfugit/concurrency/DefaultTimeoutableCompletionService.html">DefaultTimeoutableCompletionService</a></code> classes uses this
            approach to implement a <code>java.util.concurrent.CompletionService</code>-like service that will timeout and return any completed tasks and abandoning any remaining.</p>
            
        </subsection>

        <subsection name="Thread Dumps">
            <p>
                The <a href="xref/com/google/code/tempusfugit/concurrency/ThreadDump.html">ThreadDump</a> class offers a programmatic way to print a thread dump. It's not recommended for production
                code but can be handy in tracking down unexpected behaviour interactively. Using <code>ThreadDump.dumpThreads(System.out)</code>,
                for example, would yield something like the following (formatting inspired by <code>jstack</code>).
            </p>
 <source>
 Thread Reference Handler@2: (state = WAITING)
 - java.lang.Object.wait(Native Method)
 - java.lang.Object.wait(Object.java:474)
 - java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)

Thread main@1: (state = RUNNABLE)
 - java.lang.Thread.dumpThreads(Native Method)
 - java.lang.Thread.getAllStackTraces(Thread.java:1460)
 - com.google.code.tempusfugit.concurrency.ThreadDump.dumpThreads(ThreadDump.java:25)
  ...
 - com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:118)
 - com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40)

Thread Signal Dispatcher@4: (state = RUNNABLE)

Thread Finalizer@3: (state = WAITING)
 - java.lang.Object.wait(Native Method)
 - java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:120)
 - java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:136)
 - java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)
 </source>
            <p>
                 The <code>dumpThreads</code> method will also detect any Java-level deadlocks, see the
                <a href="#Deadlock_Detection">Deadlock Detection</a> section for details.
            </p>
        </subsection>

         <subsection name="Deadlock Detection">
             <p>
                 The <code><a href="xref/com/google/code/tempusfugit/concurrency/DeadlockDetector.html">DeadlockDetector</a></code> class allows you to programmatically detect basic deadlocks in your 
                 Java code. You can output deadlocks using the following code (note that printing a thread dump using the <code>ThreadDump</code> class will automatically attempt to find
                 any deadlocks).
             </p>
             <source>DeadlockDetector.printDeadlocks(System.out);</source>
             <p>
                 There are various types of deadlock in concurrent systems, broadly speaking with regard to Java,
                 they can be categorised as
             </p>
             <ul>
                 <li><p>Java monitor cyclic locking dependency</p></li>
                 <li><p>Java <code>Lock</code> cyclic locking dependency</p></li>
                 <li><p>External resource based dependency</p></li>
                 <li><p>Live lock</p></li>
             </ul>
             <p>
                 The <code>DeadlockDecector</code> class can only spot Java monitor cyclic locking problems. It's implementation
                 is basically the same as that used by <code>jconsole</code> and <code>jstack</code> and suffers the same limitations.
                 Java 1.6 versions of <code>jstack</code> and <code>jconsole</code> can additionally detect <code>Lock</code>
                 based cyclic problems. The types of deadlock it can detect can be illustrated in the example below.
             </p>
             <source>
 public void potentialDeadlock() {
     new Kidnapper().start();
     new Negotiator().start();
 }

 public class Kidnapper extends Thread {
     public void run() {
         synchronized (nibbles) {
             synchronized (cash) {
                 take(cash);
             }
         }
     }
 }

 public class Negotiator extends Thread {
     public void run() {
         synchronized (cash) {
             synchronized (nibbles) {
                 take(nibbles);
             }
         }
     }
 } </source>
             <p>
                 Here, the <code>Kidnapper</code> is unwilling to release poor Nibbles the <code>Cat</code> until he
                 has the <code>Cash</code> but our <code>Negotiator</code> is unwilling to part with the <code>Cash</code>
                 until he has poor Nibbles back in his arms. The deadlock detector displays this woeful situation as follows.
             </p>
             <source>
Deadlock detected
=================

"Negotiator-Thread-1":
  waiting to lock Monitor of com.google.code.tempusfugit.concurrency.DeadlockDetectorTest$Cat@ce4a8a
  which is held by "Kidnapper-Thread-0"

"Kidnapper-Thread-0":
  waiting to lock Monitor of com.google.code.tempusfugit.concurrency.DeadlockDetectorTest$Cash@7fc8b2
  which is held by "Negotiator-Thread-1"
             </source>
         </subsection>

         <subsection name="Miscellaneous">
            <p>Some additional thread utilities include the following</p>
            <ul>
                <li><p><code>ThreadUtils.threadIsWaiting</code></p>
            <p>The static method <code>ThreadUtils.threadIsWaiting(Thread)</code> offers a <code><a href="xref/com/google/code/tempusfugit/temporal/Condition.html">Condition</a></code>
             that allows you to test if a thread is waiting. Combining the condition with some classes from the <a href="time.html#Conditions_and_Waiting">temporal</a> package allows you to wait for a
             thread to <b>not</b> be in the waiting state, for example. Using tempus-fugit, you would express is something like the following.
         </p>
             <source>waitOrTimeout(not(threadIsWaiting(thread)), seconds(10)); </source>
            </li>
                <li>
             <p>As a convenience class, the <code><a href="xref/com/google/code/tempusfugit/concurrency/DefaultThreadFactory.html">DefaultThreadFactory</a></code> offers an implementation of <code>java.util.concurrent.ThreadFactory</code>
             that creates a thread using the single argument constructor of <code>Thread</code>.</p>
                 </li>          
            </ul>

         </subsection>
        </section>

        <section name="Concurrency Utilities">
        <subsection name="Countdown Latch with Timeout">
        <p>
            Using an instance of a <code>java.util.concurrent.CountDownLatch</code>, we can wait for the latch to count
            down to zero, blocking the calling thread before continuing. When passing in a timeout, the method returns <code>true</code>
            if the count reached zero or false if the timeout expires.
        </p>
        <p>
            To make the timeout more explicit, the <code><a href="xref/com/google/code/tempusfugit/concurrency/CountDownLatchWithTimeout.html">CountDownLatchWithTimeout</a></code>
            class will throw a <code>TimeoutException</code> rather than force you to check. Using a static import, the
            example looks like the following.
        </p>
        <source>
private final CountDownLatch startup = new CountDownLatch(1);

public void waitForStartup() throws InterruptedException, TimeoutException {
    await(startup).with(TIMEOUT);
} </source>
        <p>
            The use of the <code>with</code> method is required. Following the <a href="http://pequenoperro.blogspot.com/2009/02/more-on-micro-dsls.html">micro-DSL</a>
            approach, it is the <code>with</code> that actually does the waiting. Calling the <code>await</code> method
            on it's own will not block.
        </p>
        </subsection>

       <subsection name="Timeoutable Completion Service">
       <p>
           The <code><a href="xref/com/google/code/tempusfugit/concurrency/TimeoutableCompletionService.html">TimeoutableCompletionService</a></code>
           interface describes a service similar to a <code>java.util.concurrent.CompletionService</code> except that it
           will timeout after a specified duration if all results havn't yet been retrieved.
       </p>
       <p>
           The default implementation, <code><a href="xref/com/google/code/tempusfugit/concurrency/DefaultTimeoutableCompletionService.html">DefaultTimeoutableCompletionService</a></code>,
           delegates to an underlying <code>CompletionService</code> but will stop waiting for submitted tasks to complete
           after a given timeout.
       </p>
       <p>
           If the timeout expires before all tasks have been completed, the <code>DefaultTimeoutableCompletionService</code>
           will throw a <code>TimeoutException</code>. The exception thrown will also contain the results from any tasks
           that did manage to complete before the timeout. If all the submitted tasks complete before the timeout expires, the
           results are returned from the <code>submit</code> method and no exceptions are thrown.
       </p>
       <p>
           In the example below, we'd like to create a status monitoring application that will output the status of a
           set of probes to a web page. However, the web page must be loaded within a few seconds regardless of whether
           all the probes have returned their results. The completion service can be used to execute individual status
           probe tasks in parallel, timing out after some duration.
       </p>
           <source>
private DefaultTimeoutableCompletionService completionService = new DefaultTimeoutableCompletionService(new ExecutorCompletionService(...));               

public void probe() {
    try {
        List&lt;Callable&lt;Result&gt;&gt; probes = factory.create();
        List&lt;Result&gt; results = completionService.submit(probes);
        write(results);
    } catch (TimeoutExceptionWithFutures e) {
        write(getResultsFrom(e));
    } catch (ExecutionException e) {
        throw new RuntimeException(e);
    }
} </source>
       <p>
           Here, the list of tasks to run in parallel is created by some factory class and assigned to the <code>probes</code>
           variable. These are just a list of <code>Callable</code> objects which will be executed by the underlying
           <code>Executor</code>, in our case, they'll look up the status of some probe and return a <code>Result</code>
           object.
       </p>
       <p>
           The <code>DefaultTimeoutableCompletionService</code> is then used to schedule execution of the tasks with the
           <code>submit</code> method. At this point, the code will block and wait for all results to be returned or for
           the <code><a href="xref/com/google/code/tempusfugit/concurrency/TimeoutExceptionWithFutures.html">TimeoutExceptionWithFutures</a></code>
           to be thrown. In the case of all tasks completing within the timeout, the results are just outputted using the
           <code>write</code> method.
       </p>
       <p>
           For the case where the completion service timed out, a <code>TimeoutException</code> is thrown which includes
           any completed results. The <code>write</code> method in this case can just extract the partial set of results
           from the exception.
       </p>
       <p>
           The default timeout for the service is thirty seconds but this can be changed using an alternative constructor.
       </p>
       </subsection>

        </section>

        <section name="JUnit Integration">
        <p>
            The majority of abstractions and classes from tempus-fugit can be used within your testing framework of choice
            but there are also a couple of direct <a href="http://junit.org">junit</a> integrations that may be of use to you.
        </p>
        <subsection name="Intermittent Tests">
        <p>
            As much as possible, you aim to have a completely deterministic tests but despite your best efforts,
            the odd flickering test can still get through. Occasionally, you might want to run such a test repeatedly to
            get an idea of its indeterminacy. The <code><a href="xref/com/google/code/tempusfugit/concurrency/Intermittent.html">Intermittent</a></code>
            annotation can be combined with the <code><a href="xref/com/google/code/tempusfugit/concurrency/IntermittentTestRunner.html">IntermittentTestRunner</a></code>
            to provide this behaviour along side <a href="http://junit.org/">junit</a>.
        </p>
        <p>
            You simply mark a junit test method (or class) as potentially intermittent using the <code>Intermittent</code>
            annotation as follows.
        </p>
        <source>
@Test
@Intermittent
public void flickering() {
   // ...
}</source>       
       
        <p>
            You can then use the <code>@RunWith</code> annotation to run the test using the <code>IntermittentTestRunner</code>.
            Any <code>@Before</code> or <code>@After</code> methods will be run once for each test repetition. The
            example below also shows that the repetition count can be overridden on the method annotation.
        </p>
        <source>
<b>@RunWith(IntermittentTestRunner.class)</b>
public class IntermittentTestRunnerTest {

    private static int testCounter = 0;
    private static int afterCounter = 0;
    private static int afterClassCounter = 0;

    @Test
    @Intermittent(<b>repetition = 99</b>)
    public void annotatedTest() {
        testCounter++;
    }

    @After
    public void assertAfterIsCalledRepeatedlyForAnnotatedTests() {
        assertThat(testCounter, is(equalTo(++afterCounter)));
    }

    @AfterClass
    public static void assertAfterClassIsCalledOnce() {
        assertThat(++afterClassCounter, is(equalTo(1)));
    }

    @AfterClass
    public static void assertannotatedTestRunsMultipleTimes() {
        assertThat(testCounter, is(equalTo(99)));
    }
}</source>
            <p>
                If you annotate the class rather than individual test methods, every test method of the class will be
                treated as if it were marked as <code>@Intermittent</code>.
            </p>
            <source>
@RunWith(IntermittentTestRunner.class)
@Intermittent(repetition = 10)
public class IntermittentTestRunnerTest {

    private static int testCounter = 0;

    @Test
    public void annotatedTest() {
        testCounter++;
    }

    @Test
    public void anotherAnnotatedTest() {
        testCounter++;
    }

    @AfterClass
    public static void assertAnnotatedTestRunsMultipleTimes() {
        assertThat(testCounter, is(equalTo(20)));
    }

}</source>
        </subsection>

        <subsection name="Parallel Tests">
            <p>
                The tempus-fugit library allows you to run tests methods within classes in parallel.
                Each test method within a class will run on its own thread and in parallel with any other
                test methods in that class. The number of threads for a given test class will be equal to the number
                of test methods within that class.
            </p>
            <p>
                You can use the <a href="xref/com/google/code/tempusfugit/concurrency/ConcurrentTestRunner.html"><code>ConcurrentTestRunner</code></a>
                runner to run all test methods within a class in parallel. Simply mark your test to be <code>@RunWith</code>
                the <code>ConcurrentTestRunner</code> class as below.
            </p>
        <source>
@RunWith(ConcurrentTestRunner.class)
public class ConcurrentTestRunnerTest {

    @Test
    public void shouldRunInParallel1() {
        System.out.println("I'm running on thread " + Thread.currentThread().getName());
    }

    @Test
    public void shouldRunInParallel2() {
        System.out.println("I'm running on thread " + Thread.currentThread().getName());
    }

    @Test
    public void shouldRunInParallel3() {
        System.out.println("I'm running on thread " + Thread.currentThread().getName());
    }
}        </source>
        <p>
            In this example, each of the individual test methods are run once but in their own thread, all spawned roughly
            at the same time. The output from the above might look like the following.
        </p>
            <source>
I'm running on thread ConcurrentTestRunner-Thread-0
I'm running on thread ConcurrentTestRunner-Thread-2
I'm running on thread ConcurrentTestRunner-Thread-1 </source>

        </subsection>

        <subsection name="Load / Soak Tests">

        <p>
            The tempus-fugit library offers a <a href="xref/com/google/code/tempusfugit/concurrency/RepeatingRule.html"><code>RepeatingRule</code></a>
            and <a href="xref/com/google/code/tempusfugit/concurrency/ConcurrentRule.html"><code>ConcurrentRule</code></a>
            that can be used to run a test method multiple times and across multiple threads. This can be useful when
            writing load or soak tests. For example, you might want to sanity check that your synchronisation is working
            under load. Both rules work use an annotation and can be used independently or together.
        </p>
        <p>
            To run multiple instances of a single test method in parallel, you annotate the test method with the
            associated <a href="xref/com/google/code/tempusfugit/concurrency/Concurrent.html"><code>Concurrent</code></a>
            annotation and declare the rule in your test class. For example, you might test the
            <code>AtomicInteger</code> class in a similar way to this.
        </p>
        <source>
public class RunConcurrentlyTest {

    @Rule public ConcurrentRule rule = new ConcurrentRule();

    private static final AtomicInteger counter = new AtomicInteger();

    @Test
    @Concurrent (count = 5)
    public void runsMultipleTimes() {
        counter.getAndIncrement();
    }
 } </source>
        <p>
           Here, the test method is run in parallel across five threads which may or may not expose potential threading
           issues. It's not recommended you use this as your only concurrent testing strategy but it may occasionally
           find a use.
        </p>
        <p>
            To run a test method multiple times, you can take advantage of the <a href="xref/com/google/code/tempusfugit/Repeating/Repeating.html"><code>Repeating</code></a>
            annotation and declare the rule in your test class. This is similar to using the <code>Intermittent</code>
            annotation but unlike using the <code>@RunWith</code> mechanism, using the <code>Rule</code> will <i>not</i>
            execute any <code>@Before</code> or <code>@After</code> methods between runs. Using <code>Repeating</code> is
            also more explicit that you intend to run some kind of load test rather than indicating that a test is intermittently 
            failing.
        </p>
        <source>
public class RepeatingRuleTest {

    @Rule public RepeatingRule rule = new RepeatingRule();

    private static int counter = 0;

    @Test
    @Repeating(repetition = 99)
    public void annotatedTest() {
        counter++;
    }

    @After
    public void annotatedTestRunsMultipleTimes() {
        assertThat(counter, is(99));
    }
} </source>

        <p>
            Combining the <a href="xref/com/google/code/tempusfugit/concurrency/Concurrent.html"><code>Concurrent</code></a>
            with the <a href="xref/com/google/code/tempusfugit/Repeating/Repeating.html"><code>Repeating</code></a>
            annotation allows you to run a test method repeatedly and across threads. For example, running the following
        </p>
        <source>
public class RunConcurrentlyTest {

    @Rule public ConcurrentRule concurrently = new ConcurrentRule();
    @Rule public RepeatingRule repeatedly = new RepeatingRule();

    private static final AtomicInteger counter = new AtomicInteger();

    @Test
    <b>@Concurrent (count = 5)
    @Repeating (repetition = 10)</b>
    public void runsMultipleTimes() {
        counter.getAndIncrement();
    }
 } </source>
        <p>
            Will repeat the test method ten times in five threads. Each thread will run the test method ten times, so in
            our example, the counter will be incremented to fifty.
        </p>

        </subsection>

        <subsection name="Wait for Assertions">
        <p>
            The <a href="xref/com/google/code/tempusfugit/temporal/WaitFor.html"><code>WaitFor</code></a> class can be
            used to wait for a condition to hold. You can use it within your tests to wait for some asynchronous process
            to complete and so make an assertion in a test.
        </p>
        <p>
            In the example below, a test verifies that the action of clicking a button will toggle some switch to a
            different position. However, this test may or may not pass if the <code>clickButton()</code> kicks off an
            asynchronous process to update the toggle position. It may return immediatly having not yet changed the position.
        </p>
<source>
@Test
public void toggleButton() {
    assertThat(toggle, is(ON));
    clickButton();
    assertThat(toggle, is(OFF));
} </source>
        <p>
            Rewriting the test using a <code>WaitFor</code> would look like this
        </p>
<source>
@Test
public void toggleButton() throws TimeoutException {
    assertThat(toggle, is(ON));
    clickButton();
    waitOrTimeout(new Condition() {
        public boolean isSatisfied() {
            return toggle == OFF;
        }
    }, seconds(5));
} </source>

        <p>
            Here, the test will retry the <code>Condition</code> for five seconds before finally giving up and failing the
            test. If the condition is true immediately, the wait will continue immediately and the test will continue.
            By extracting a method to create the <code>Condition</code>, you can further refactor the test to be more
            expressive and start to create a library of reusable conditions.
        </p>
<source>
@Test
public void toggleButton() throws TimeoutException {
    assertThat(toggle, is(ON));
    clickButton();
    waitOrTimeout(toggleIs(OFF), seconds(5));
}

private Condition toggleIs(final Position position) {
    return new Condition() {
        public boolean isSatisfied() {
            return toggle == position;
        }
    };
}
</source>
        <p>
            These mechanism are more fully described in the <a href="time.html">time-dependence</a> section.
        </p>
        </subsection>

        <subsection name="Interrupt Capturing Thread Stub">
        <p>
            It can be tricky to test that an interrupt has been called on a thread because of the possibility of race conditions between calling <code>interrupt</code> and checking
            the status of the interrupt flag using <code>Thread.isInterrupted()</code> or <code>Thread.interrupted</code>. For example, the interrupt status can be reset when a thread
            goes into the <code>TERMINATED</code> state. You can use the <code>WaitFor</code> class to express an assertion must be true within a given time (as below) but in this case,
            the race conditions can still occur (due to the frequency of the check whilst waiting). In the example below, the created thread will perform some blocking function that can
            be interrupted (for example, sleeping) and we're testing that the call to <code>interrupt</code> will wake and change the interrupt status flag (asserting against <code>thread.isInterrupted</code>).
        </p>
            <source>
@Test (timeout = 500)
public void interrupted() throws TimeoutException, InterruptedException {
    final Thread thread = new Thread(new Runnable(...));
    thread.start();
    waitOrTimeout(threadIsWaiting(thread), millis(500));
    thread.interrupt();
    <b>waitOrTimeout(new Condition() {
        public boolean isSatisfied() {
            return thread.isInterrupted();
        }
    }</b>, millis(500));
} </source>
            <p>
                It may be simpler to use a <i>stub</i> to capture the interrupt. The <code><a href="xref/com/google/code/tempusfugit/concurrency/InterruptCapturingThread.html">InterruptCapturingThread</a></code> class of tempus-fugit is just a stub extending <code>Thread</code>
                which records and gives access to stack traces of threads that call <code>interrupt</code> on it.
            </p>
            <source>
@Test (timeout = 500)
public void interrupted() throws TimeoutException, InterruptedException {
    InterruptCapturingThread thread = new InterruptCapturingThread(new Runnable(...));
    thread.start();
    waitOrTimeout(threadIsWaiting(thread), millis(500));
    thread.interrupt();
    waitOrTimeout(not(threadIsWaiting(thread)), millis(500));
    <b>assertThat(thread.getInterrupters().isEmpty(), is(false));</b>
} </source>
            <p>
                For testing purposes, you can also get a view on the stack traces of the threads that called <code>interrupt</code> on your thread. Calling <code>thread.printStackTraceOfInterruptingThreads(System.out)</code>
                from the example above would show something like the following.
            </p>
            <source>
java.lang.Thread.getStackTrace(Thread.java:1409)
   com.google.code.tempusfugit.concurrency.InterruptCapturingThread.interrupt(InterruptCapturingThread.java:61)
   com.google.code.tempusfugit.concurrency.InterruptCapturingThreadTest.interrupted(InterruptCapturingThreadTest.java:39)
   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
   java.lang.reflect.Method.invoke(Method.java:585)
   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
   org.junit.internal.runners.statements.FailOnTimeout$1.run(FailOnTimeout.java:28) </source>
        </subsection>


        </section>

        <section name="Callables">
            <subsection name="Callable Adapter">
                <p>
                    The <code>java.util.concurrent.Executors</code> class has helper methods to convert from a
                    <code>Runnable</code> to a <code>Callable</code> but lacks a counterpart to convert a <code>Callable</code>
                    to a <code>Runnable</code>. This is presumably because a <code>Runnable</code> lacks the ability to
                    throw exceptions or return values.
                </p>
                <p>
                    Both <code>Runnable</code> and <code>Callable</code> are handy interfaces to express closure-like functionality
                    in Java. Discounting their close relationship to concurrency mechanisms in Java, they both really
                    just represent something that can be called. Choosing between the two, the <code>Callable</code> is
                    more powerful.
                </p>
                <p>
                    The <code><a href="xref/com/google/code/tempusfugit/concurrency/CallableAdapter.html">CallableAdapter</a></code> class will convert from a <code>Callable</code> into a <code>Runnable</code>
                    wrapping any exception as a <code>RuntimeException</code> and discarding any return type. This allows
                    you to write general task code in the form of a <code>Callable</code> without necessarily being hampered
                    if you need to pass in a <code>Runnable</code> to some framework code.
                </p>
                <p>
                    As a concrete example, Java's <code>ScheduledExecutorService</code> class doesn't allow you to schedule
                    a task with a fixed delay or at a fixed rate. The interface takes a <code>Runnable</code>. However,
                    using the adapter you can schedule a <code>Callable</code> at a fixed rate (ignoring the result). The
                    underlying <code>Callable</code> task could then be used elsewhere where the result is actually used.
                </p>
            </subsection>

            <subsection name="tempus-fugit Callable">
            <p>The <code><a href="xref/com/google/code/tempusfugit/concurrency/Callable.html">Callable</a></code> interface extends <code>java.util.concurrent.Callable</code> but allows you to specify the
                exception as a generic type. This class has a fairly limited usage and isn't recommended over the standard
                Java version. Instead, if you create a method that takes a <code>java.util.concurrent.Callable</code> as a
                argument, calling it will force the method to throw <code>Exception</code>. If instead, you pass in a
                <code>com.google.code.tempusfugit.concurrency.Callable</code>, you can specify the specific exception to
                throw and therefore avoid being forced to throw <code>Exception</code>. For example</p>
                <source>
public &lt;T&gt; T foo(java.util.concurrent.Callable&lt;T&gt; callable) throws <b>Exception</b> {
    return callable.call();
} </source>
                <p>Whereas using the tempus-fugit version allows a more specific exception to be thrown.</p>
                <source>
public &lt;T&gt; T bar(com.google.code.tempusfugit.concurrency.Callable&lt;T, <b>RuntimeException</b>&gt; callable) {
    return callable.call();
} </source>
            </subsection>
        </section>
    </body>

</document>